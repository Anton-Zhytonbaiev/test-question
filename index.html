<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="styles.css">
  <title>Test iT.Artel</title>
</head>
<body>
  <div class="container">
    <h1>Верстка та Загальне</h1>
    <ol>
      <li>
        <p>
          1. Так, за допомогою JS можна змінювати значення цих псевдоелементів. За допомогою методу "window.getComputedStyle()", куди передамо два пареметра, наш елемент і псевдоелемент. Далі ми користуємося методом Element.style, де "Element" це наш елемент, а "style" властивість яку ми хочемо змінити.
        </p>
      </li>
      <li>
        <p>
          2. 1em це одиниця розміру, яка прив'язується до батьківського елементу. Для прикладу, якщо в батьківському елементі розмір шрифту 12px, то встановлення 1em в дочірньому зробить шрифт також розміром 12px. Ця властивість допомагає нам не змінювати вручну всі розміри, а тільки в батьківському, і в такому випадку всі дочірні пропорційно збільшаться/зменшаться.
        </p>
      </li>
      <li>
        <p>
          3. Я cкористався трьома способами, в першому використовую "inline-block", в другому випадку "display: flex", в третьому "display: grid"
        </p>
        <div class="container-1">
          <div class="block-1"></div>
          <div class="block-1"></div>
          <div class="block-1"></div>
        </div>
        <div class="container-2">
          <div class="block-2"></div>
          <div class="block-2"></div>
          <div class="block-2"></div>
        </div>
        <div class="container-3">
          <div class="block-3"></div>
          <div class="block-3"></div>
          <div class="block-3"></div>
        </div>
      </li>
      <li>
        <p>
          4. Для сортування ми можемо скористатися методом sort(), який приймає функцію колбек. Далі використовуємо конструктор "new Date()", щоб ми могли порівняти наші дати. 
        </p>
        <pre class="block__code">
          <code>
          array.sort((a, b) => {
            const dateA = new Date(a.date);
            const dateB = new Date(b.date);
            return dateA - dateB;
          });
          </code>
        </pre>
      </li>
      <li>
        <p>
          5. Це код який ми будемо використовувати для "чистого" JS.
        </p>
        <pre class="block__code">
          <code>
          const root = document.querySelector('#root');

          root.addEventListener('click', function(event) {
              let id = event.target.id;

              console.log(id);
          });
          </code>
        </pre>
      </li>
    </ol>
    <h1>Angular</h1>
    <ol>
      <li>
        <p>
          1. Вони по різному приховують наші елементи. А саме *ngIf коментує і таким чином цей код навіть не потрапляє в DOM, що доволі вигідно в плані використання ресурсів (особливо якщо елемент має в собі багато елементів). Тому що [hidden] завантажує всі дані і просто встановлює "display: none".
        </p>
      </li>
      <li>
        <p>
          2. Observable це розширена версія Promise. Виконується для асинхроності, наприклад отримати дані з сервера і використати їх. Перевага в тому, що оновлюється тільки ті елементи, які "підписані" на зміни, і тільки тоді, коли щось змінюється. Також це допоможе зробити код більш зрозумілим і простим.
        </p>
      </li>
      <li>
        <p>
          3. В цьому завданні правильними є перші три твердження. Твердження "&lt;hello name="{{ name }}">&lt;/hello> відображатиме: "Welcome to name!"" не буде працювати, через неправильну назву компонента.
        </p>
      </li>
      <li>
        <p>
          4. Правильними твердження є 2, 3, і 4. В першому ми не використовуємо Output, а в п'ятому неправильно вказано ім'я компонента.
        </p>
      </li>
      <li>
        <p>
          5. Правильними твердження є 1, 2, 3, і 4. В останьому випадку, якщо властивість pathMatch: 'full' видалена, маршрут /home буде активним при будь-якій URL-адресі, Яка починається з /home.
        </p>
      </li>
      <li>
        <p>
          6. Правильними є твердження 1 і 4. В другому applyMixins просто копіює властивості, не перевіряючи їх наявність. В третьому "mover.rotate(30)" збереже орієнтацію об'єкта після повороту на 30 градусів. В п'ятому властивості MovingObject не є резервними.
        </p>
      </li>
      <li>
        <p>7.</p>
        <pre class="block__code">
          <code>
          &lt;ul>
            &lt;li *ngFor="let address of addresses">
              &lt;app-address [address]="address"></app-address>
            &lt;/li>
          &lt;/ul>
          </code>
        </pre>
      </li>
    </ol>
    <h1>Node JS</h1>
    <ol>
      <li>
        <p>
          1. Це файл конфігурації, в якому описуються всі залежності, скрипти, назва проетку. Для прикладу всі бібліотеки які ми будемо встановлювати, будуть описані тут, і вказані Їхні версії. Це потрібно щоб розробник, який склонує собі наш проект, встановив всі залежності собі на пристрій, щоб все працювало коректно.
        </p>
      </li>
      <li>
        <p>
          2. GET - запит на отримання даних. POST - створення нових даних, які ми передаємо. PUT і PATCH - оновлюють дані, або повністю, або конкретні поля. DELETE - видаляє дані.
        </p>
      </li>
      <li>
        <p>
          3. Локальне встановлення стосується конкретного проекту і не буде розповсюджене на інші. Глобальне встановлення здійснюється на рівні всього пристрою і буде розповсюджуватися на всі проекти.
        </p>
      </li>
      <li>
        <p>
          4. В консолі ми побачимо наступне:
        </p>
          <pre class="block__code">
            Statement A
            Emitted Statement - FIRST
            Emitted Statement - SECOND
            Statement B
          </pre>
          <p>У виконанні немає нічого незвичного. Весь код виконується по порядку, а прослуховувачі виконуються в порядку додавання до об'єкту після виклику.</p>
      </li>
      <li>
        5. Так як цикл не чекає завершення кожного ітераційного кроку, результати можуть виводитися у непередбачуваному порядку. Вирішенням є використання циклу "for of", так як він підтримує асинхроність.
      </li>
      <li>
        <p>
          6. За допомогою "module.exports" ми можемо експортувати зміну/функцію/об'єкт, щоб використовувати це потім в іншому місці (іншого файлу). Щоб потім імпортувати, ми маємо використовувати "require()". Приклад:
        </p>
        <pre class="block__code">
          <code>
          function sum(a, b) {
            return a + b;
          };
          
          module.exports.sum = sum;
          </code>
        </pre>
      </li>
    </ol>
    <h1>Wordpress</h1>
    <ol>
      <li>
        <p>
          1. Тільки файл "page-front.php" не буде використовуватися для відображення сторінки. Всі інші назви є допустимі, проте в них різна приорітетність, а саме спочатку шукається файл "front-page.php", потім "home.php" і в самому кінці "index.php"
        </p>
      </li>
      <li>
        <p>
          2. Правильнимим відповідями є 3 і 4.
        </p>
      </li>
    </ol>
  </div>
</body>
</html>